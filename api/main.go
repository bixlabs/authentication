package main

import (
	"fmt"
	"io"
	"net/http"
	"os"
	"time"

	"github.com/bixlabs/authentication/api/authentication"
	_ "github.com/bixlabs/authentication/api/docs" // docs is generated by Swag CLI, you have to import it.
	"github.com/bixlabs/authentication/authenticator/interactors/implementation"
	email "github.com/bixlabs/authentication/authenticator/provider/email/implementation"
	"github.com/bixlabs/authentication/database/user/sqlite"
	emailProviders "github.com/bixlabs/authentication/email/providers"
	"github.com/bixlabs/authentication/tools"
	"github.com/bixlabs/authentication/tools/util"
	"github.com/caarlos0/env"
	"github.com/gin-gonic/gin"
	_ "github.com/joho/godotenv/autoload"
	_ "github.com/mattn/go-sqlite3"
	ginSwagger "github.com/swaggo/gin-swagger"
	"github.com/swaggo/gin-swagger/swaggerFiles"
)

const readHeaderTimeoutSeconds = 20
const writeHeaderTimeoutMinutes = 2
const powerForHeaderBytes = 20

// @title Go-Authenticator
// @version 1.0
// @description Leverage of authentication functionality

// @contact.name API Support
// @contact.url https://bixlabs.com/
// @contact.email jarrieta@bixlabs.com
// @name Authorization

// @license.name MIT
// @license.url https://opensource.org/licenses/MIT
// @BasePath /v1/

func main() {
	tools.InitializeLogger()
	router := NewGinRouter()
	userRepo, closeDB := sqlite.NewSqliteStorage()
	defer closeDB()
	sender := email.NewSender(emailProviders.NewEmailProvider())
	authOperations := implementation.NewAuthenticator(userRepo, sender)
	passwordManager := implementation.NewPasswordManager(userRepo, sender)
	authentication.NewAuthenticatorRESTConfigurator(authOperations, passwordManager, router)
	runGinRouter(router, getRestConfiguration().Port)
}

func NewGinRouter() *gin.Engine {
	result := gin.New()
	result.Use(addRequestID())
	result.Use(logger())
	result.Use(gin.Recovery())
	configureSwagger(result)
	return result
}

func configureSwagger(result *gin.Engine) gin.IRoutes {
	return result.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerFiles.Handler))
}

func runGinRouter(router *gin.Engine, port string) {
	server := createHTTPServer(router, port)
	tools.Log().Info(fmt.Sprintf("Server listening in port: %s", port))
	err := server.ListenAndServe()

	if err != nil {
		tools.Log().WithError(err).Panic("running the router for the rest configuration")
	}
}

func createHTTPServer(router http.Handler, port string) *http.Server {
	return &http.Server{
		Addr:              ":" + port,
		Handler:           router,
		ReadHeaderTimeout: readHeaderTimeoutSeconds * time.Second,
		ReadTimeout:       1 * time.Minute,
		WriteTimeout:      writeHeaderTimeoutMinutes * time.Minute,
		MaxHeaderBytes:    1 << powerForHeaderBytes,
	}
}

func getRestConfiguration() RestConfiguration {
	result := RestConfiguration{}
	err := env.Parse(&result)
	if err != nil {
		tools.Log().WithError(err).Panic("parsing the env variables for the rest configuration failed")
	}
	return result
}

func addRequestID() gin.HandlerFunc {
	return func(c *gin.Context) {
		requestID := util.GenerateUniqueID()
		c.Set("rid", requestID)
		c.Header("X-Request-Id", requestID)
		c.Next()
	}
}

func logger() gin.HandlerFunc {
	if util.IsDevEnvironment() {
		return gin.Logger()
	}

	logFile, _ := os.Create("gin.log")
	gin.DefaultWriter = io.MultiWriter(logFile)
	return gin.LoggerWithFormatter(customFormatter)
}

func customFormatter(param gin.LogFormatterParams) string {
	return fmt.Sprintf("%s - %s - [%s] \"%s %s %s %d %s \"%s\" %s\"\n",
		param.Keys["rid"],
		param.ClientIP,
		param.TimeStamp.Format(time.RFC1123),
		param.Method,
		param.Path,
		param.Request.Proto,
		param.StatusCode,
		param.Latency,
		param.Request.UserAgent(),
		param.ErrorMessage,
	)
}

type RestConfiguration struct {
	Port string `env:"AUTH_SERVER_PORT" envDefault:"8080"`
}
